/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;

/**
 *  Usercode Components
 */
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }

    //flag is set to true when main begins
    static boolean flag = false;     
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**

 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            ELSE, IF, PREFIX, SUFFIX, PLUS, LBRACK, RBRACK, LPAREN, RPAREN, COMMA, IDENT;
terminal String     STRING_LITERAL;


/*  Non terminals */
/*
non terminal String definition_list;
non terminal String program, definition, branch, fun_args, expr, choose, concat, if_expr, fix;
*/
non terminal String program, fun_def, fun_def_list, main_calls_list, def_args, fun_def_expr, main_call, main_args;
non terminal String more1, concat1, concat2, if_expr, choose, fix, more2, def_arg, main_arg;
/**
 *  Precedence Declarations
 */

/**
 *  The Grammar Rules
 */
program			::= fun_def_list:f {: System.out.println("public class Main {\n"+f+"}\n"); :}
;
fun_def_list	::= fun_def:f1 fun_def_list:f2 {: RESULT = f1 + f2; :}
				  | main_calls_list:m          {: RESULT = "\tpublic static void main(String args[]){\n" + m + "\t}\n"; :}
;
main_calls_list	::= main_call:m1 main_calls_list:m2 {: RESULT = m1 + m2; :}
				  |{: RESULT = ""; :}
;
fun_def			::= IDENT:i LPAREN def_args:d RPAREN LBRACK fun_def_expr:f RBRACK {: RESULT = "\tpublic static String "+i+"("+d+"){\n"+"\t\treturn "+f+";\n\t}\n"; :}
				  | IDENT:i LPAREN  RPAREN LBRACK fun_def_expr:f RBRACK {: RESULT = "\tpublic static String "+i+"(){\n"+"\t\treturn "+f+";\n\t}\n"; :}
				  
;
main_call		::= IDENT:i LPAREN main_args:m RPAREN {: RESULT = "\t\tSystem.out.println("+i+"("+m+")"+");\n"; :}
				  | IDENT:i LPAREN  RPAREN  {: RESULT = "\t\tSystem.out.println("+i+"()"+");\n"; :}
;
/*******/
def_arg			::= IDENT:i {: RESULT = "String " + i; :}
;
def_args		::= def_arg:d more1:m {: RESULT = d + m; :}
;
more1			::= COMMA def_arg:d more1:m {: RESULT = ", " + d + m; :}
				  |{: RESULT = ""; :}
;
/*******/
fun_def_expr	::= STRING_LITERAL:s concat1:c {: RESULT = s + c; :} 
				  | IDENT:i choose:c1 concat1:c2 {: RESULT = i + c1 + c2; :}
				  | if_expr:i {: RESULT = i; :}
;
concat1			::= PLUS fun_def_expr:f {: RESULT = " + " + f; :}
				  |{: RESULT = ""; :}
;
choose			::= LPAREN fun_def_expr:f RPAREN {: RESULT = "("+f+")"; :}//function call
				  | LPAREN RPAREN{: RESULT = "()"; :}
				  | {: RESULT = ""; :}//just identifier
;
if_expr         ::= IF LPAREN fun_def_expr:e1 fix:f fun_def_expr:e2 RPAREN //formated like this for readability; idents don't matter
						fun_def_expr:e3
					ELSE
						fun_def_expr:e4
				  {: RESULT = "(("+e2+"."+f+"("+e1+")"+")?"+e3+":"+e4+")"; :} 
;
fix 			::= SUFFIX {: RESULT = "endsWith"; :}
		  		  | PREFIX {: RESULT = "startsWith"; :}
;  
/*******/
main_arg		::= STRING_LITERAL:s concat2:c {: RESULT = s + c; :}
				  | IDENT:i LPAREN main_args:m RPAREN concat2:c {: RESULT = i +"("+m+")"+ c; :}
				  | IDENT:i LPAREN  RPAREN{: RESULT = i + "()"; :}
;
main_args		::=  main_arg:m1 more2:m2 {: RESULT = m1 + m2; :}
;
more2			::= COMMA main_arg:m1 more2:m2{: RESULT = ", " + m1 + m2; :}
				  | {: RESULT = ""; :}
;
concat2			::= PLUS main_arg:m{: RESULT = " + " + m; :}
				  |{: RESULT = ""; :}
;
/*******/

